#include <iostream>
#include <iomanip>
#include <vector>
#include <algorithm>
#include <cassert>

using namespace std;

//************************************************************************************************************
//Перегрузка инкремента

//class Day{
//private:
//    int m_day;
//public:
//    Day(int day = 1) : m_day(day){}
//    void getDay() const { cout << m_day << endl; }
//    //напишем перегрузку оператора инкремента ++
//    Day& operator++ () {
//        if(m_day == 31) m_day = 1;
//        else m_day++;
//        return *this;//оператор будет возвращать сам объект, так как "зис" (this) это указательна объект, *this - это
//        //сам объект.
//    }
//};


//int main()
//{
//    Day today(24);
//    ++today;//перегрузили оператор версии префикс.
//    //today++;//если захотим применить оператор постфикс для типа нашего объекта, то выдаст ошибку
//    //так как мы его ещё не перегрузили
//    today.getDay();

//***********************************************************************************************************
//перегрузка постфикс. Фиктивная переменная

//class Day{
//private:
//    int m_day;
//public:
//    Day(int day = 1) : m_day(day){}
//    void getDay() const { cout << m_day << endl; }
//    //напишем перегрузку оператора инкремента ++
//    Day& operator++ () {
//        if(m_day == 31) m_day = 1;
//        else m_day++;
//        return *this;//оператор будет возвращать сам объект, так как "зис" (this) это указательна объект, *this - это
//        //сам объект.
//    }
//    Day operator++ (int){//здесь используем параметр типа int, но не даём ему даже имя, так как он фиктивный
//        Day temp(m_day);//создаём временный объект на основе текущего объекта
//        //далее мы должны увеличить наш текущий объект (мы его получаем через *this)
//        ++(*this);//и его мы должны увеличить, для этого применяем оператор версии префикс для текущего объекта
//        return temp;//далее мы должны вернуть временный объект, тот объект, который ещё не был увеличен.
//        //Так же в этом случае мы возвращаем просто Day без значка амперсанд (&), а в первом случае мы его использовали -
//        //возвращение было по ссылке, это связано с тем, что в этом методе создаётся локальная переменная temp, которая
//        //удаляется по завершению работы оператора и если мы будем пытаться возвращать временный объект по ссылке, то
//        //мы вернём ссылку на уже удалённый объект. Мы не можем возвращать локальный объект по ссылке.
//    }
//    //первая версия этого оператора более эффективна в памяти и по времени его выполнения, так как не создаётся ни какой
//    //временной переменной и нету копирования при возврате данного объекта.
//    //тоже самое касается и операторов дикрементов, когда уменьшаем объект

//};


//int main()
//{
//    Day today(24);
//    today++;//если захотим применить оператор постфикс для типа нашего объекта, то выдаст ошибку
//    //так как мы его ещё не перегрузили, чтобы это сделать используют фиктивную переменную или параметр для оператора
//    //версии постфикс
//    (today++).getDay();//при этом, если мы вызовем на этой же строке метод getDay. Мы увидим, что сначала
//    //был вызван метод getDay для старого объекта (до увеличения), а за тем уже после увеличения
//    today.getDay();

//*******************************************************************************************************
//Шаблоны функций и классов
//шаблоны функций:

//мы хотим написать универсальную функцию max которая бы сравнивала объекты разных типов
//воспользуемся перегрузкой функции различными типами данных. Функция имеет одно имя, но мы напишим несоколько
//версий - для разных переменных. Нам нужно будет создать много варианнтов этой функции и шаблоны функций
//решают эту проблему. Создаём шаблон:

//template <typename T>//template - ключевое слово, что это шаблон. В угловых скобках пишутся параметры этого шаблона
// //<сначала пишется ключевое слово typename, далее параметр шаблона "T">. В некоторых случаях в место typename
// //может писаться слово class, но этот класс не имеет ничего общего с обычным классом
//T max_t(T a, T b) {//далее, в место какого-то конкретного типа данных используем тип T
//    return (a>b) ? a : b;
//}


//int main()
//{
// //попробуем вызвать такую функцию max:
//    cout << max_t(4, 8) << endl;//попробуем сначала с целыми числами
//    cout << max_t(9.32, 7.2342) << endl;//для дробных чисел
//    cout << max_t('b', 'C') << endl;//для char

//*************************************************************************************************************
//как же устроен внутри этот шаблон?

//template <typename T>
//T max_t(T a, T b) {
//    return (a>b) ? a : b;
//}


//int main()
//{

//    cout << max_t(4, 8) << endl;
//    cout << max_t(9.32, 7.2342) << endl;
//    cout << max_t('b', 'C') << endl;
//    cout << max_t(12, 3) << endl;//даже в этом случае будет создано только три экземпляра шаблона данной функции
//    //будет использоваться самый первый экземпляр шаблона функции
//    //экземпляр шаблона функции создаётся в тот момент когда вызывается эта функция с определённым типом данных
//    //и когда вызывается несколько раз эта функция с этим типом данных, то создаётся всеголишь один экземпляр
//    //с этим типом данных

//*************************************************************************************************************
//как можно усовершенствовать нашу функцию?

//template <typename T>
//const T max_t(const T &a, const T &b) {//что бы функция могла принимать не только примитивные типы данных, но и
//    //пользовательские, она должна при нимать занчения по ссылке, так как значения не должны изменяться внутри этой
//    //функции, эта ссылка должна быть константной. И возвращаемым объектом тоже может быть константная ссылка
//    return (a>b) ? a : b;
//}

//class Day{
//private:
//    int m_day;
//public:
//    Day(int d) : m_day(d){}
//    void getDay() const { cout << m_day << endl; }
//    //Перегрузим оператор больше через дружественную функцию
//    friend bool operator>(const Day& d1, const Day& d2){
//        return (d1.m_day > d2.m_day);
//    }
//};

//int main()
//{

//    cout << max_t(4, 8) << endl;
//    cout << max_t(9.32, 7.2342) << endl;
//    cout << max_t('b', 'C') << endl;
//    cout << max_t(12, 3) << endl;
//    //попробуем применить нашу функцию к пользовательскому типу данных, например к классу Date, при этом может возникнуть
//    //проблема, что функция не знает какие поля и как можно сравнивать (поле может быть одно или 20 и как все их
//    //сравнивать?). Как решение, нужно будет перегрузить оператор сравнения для данного типа (перегрузить оператор ">")
//    Day d1(5), d2(10);
//    Day d3 = max_t(d1, d2);
//    d3.getDay();
//    //функцию мы назвали не max, а max_t, так как обычная функция max уже существует в языке C++ и является шаблонной.
//    cout << max(4, 8) << endl;

//*****************************************************************************************************************
//шаблоны классов
//нужно создать контейнерный класс который сможет работать с различными типами данных

//template <class T> // шаблон класса. Т - параметр шаблона класса
//class Array{//Создаём сам класс Array
//private:
//    int m_length;
//    T *m_data;//создаётся указатель типа Т
//public:
//    Array(){//конструктор поумолчанию
//        m_length = 0;
//        m_data = nullptr;
//    }
//    Array(int length){//конструктор с параметром который выделяет динамически память длиной переданного параметра
//        m_data = new T[length];
//        m_length = length;
//    }
//    ~Array(){//диструктор
//        delete[] m_data;
//    }
//    void Erase(){
//        delete[] m_data;// Указываем m_data значение nullptr, чтобы на выходе не получить висячий указатель!
//        m_data = nullptr;
//        m_length = 0;
//    }
//    T& operator[](int index){//перегрузка оператора индексации, тип возвращаемого значения "Т"
//        assert(index >= 0 && index < m_length);//для работы требуется: #include <cassert>
//        return m_data[index];
//    }
//    int getLength(); //определяем метод и шаблон метода getLength() ниже, т. е. реализация даётся вне класса
//};

// // метод, определенный вне тела класса, нуждается в собственном определении шаблона метода
//template <typename T>
//int Array<T>::getLength() { return m_length; }// обратите внимание, имя класса - Array<T>, а не просто Array


//int main()
//{
//    //при создании объекта, мы должны указать сам класс, а, далее, параметр шаблона данного класса
//    Array<int> intArray(10);//массив целых чисел
//    Array<double> doubleArray(5);//массив действительных чисел

//**********************************************************************************************************
//не типовые параметры шаблонов

//template <class T> // шаблон класса. Т - параметр шаблона класса
//class Array{//Создаём сам класс Array
//private:
//    int m_length;
//    T *m_data;//создаётся указатель типа Т
//public:
//    Array(){//конструктор поумолчанию
//        m_length = 0;
//        m_data = nullptr;
//    }
//    Array(int length){//конструктор с параметром который выделяет динамически память длиной переданного параметра
//        m_data = new T[length];
//        m_length = length;
//    }
//    ~Array(){//диструктор
//        delete[] m_data;
//    }
//    void Erase(){
//        delete[] m_data;// Указываем m_data значение nullptr, чтобы на выходе не получить висячий указатель!
//        m_data = nullptr;
//        m_length = 0;
//    }
//    T& operator[](int index){//перегрузка оператора индексации, тип возвращаемого значения "Т"
//        assert(index >= 0 && index < m_length);//для работы требуется: #include <cassert>
//        return m_data[index];
//    }
//    int getLength(); //определяем метод и шаблон метода getLength() ниже, т. е. реализация даётся вне класса
//};

// // метод, определенный вне тела класса, нуждается в собственном определении шаблона метода
//template <typename T>
//int Array<T>::getLength() { return m_length; }// обратите внимание, имя класса - Array<T>, а не просто Array

// //создадим класс с не типовым параметром
//template <class T, int size>//первый параметр - это тип (типовой), второй параметр шаблона не типовой (как пример - число)
//class StaticArray{
//private:
//    T m_array[size];
//    // и т. д.
//};

//int main()
//{
//    //при создании объекта, мы должны указать сам класс, а, далее, параметр шаблона данного класса
//    Array<int> intArray(10);//массив целых чисел
//    Array<double> doubleArray(5);//массив действительных чисел

//    //чтобы создать объект такого класса (с не типовым параметром):
//    StaticArray<int, 10> arr;//в итоге, создадим статический массив состоящий из 10 элементов типа int

//**************************************************************************************************************
//специализация шаблонов классов и функций
//явная специализация шаблонов функций

//рассмотрим следующий шаблон класса:
//template <class T>
//class Repository{
//private:
//    T m_value;
//public:
//    Repository(T value){
//        m_value = value;
//    }
//    ~Repository(){}
//    void print(){
//        std::cout << m_value << '\n';
//    }
//};


//int main()
//{
//Repository<int> nValue(7);
//Repository<double> dValue(8.4);
//nValue.print();
//dValue.print();
// //что если мы хотим изменить функцию прин только лишь для какого-то конкретного типа.
// //нужно сделать принт немного другим, когда в место Т будет подставляться double

//*********************************************************************************************************
//изменим функцию принт из предыдущего примера

//template <class T>
//class Repository{
//private:
//    T m_value;
//public:
//    Repository(T value){
//        m_value = value;
//    }
//    ~Repository(){}
//    void print(){
//        std::cout << m_value << '\n';
//    }
//};

// //пишем вне класса
//template <>
//void Repository<double>::print(){//специально при параметре Т double мы изменили функцию принт
//    cout << scientific << m_value << endl;//число будет выводиться в экспоненциальной форме записи
//}

//int main()
//{
//Repository<int> nValue(7);
//Repository<double> dValue(8.4);
//nValue.print();
//dValue.print();
// //явная специализация шаблона функции позволяет нам задать в явном виде реализацию этой функции для определённого типа
// //данных

//*************************************************************************************************************
//явная специализация шаблона класса

//template <class T>//шаблонный класс
//class Repository8{
//private:
//    T m_array[8];//внутри класса находится массив из 8-ми элементов типа Т
//public:
//    void set(int index, const T &value){//для конкретного элемента присваивает значение
//        m_array[index] = value;
//    }
//    const T& get(int index){//возвращает запрошенный элемент
//        return m_array[index];
//    }
//};
// //если будем работать с типом данных bool будет наблюдаться большой расход памяти в отличаи от необходимого
// //было бы хорошо создать такой класс Repositori8 для типа данных bool, чтобы внутри этого класса данные хранились не
// //в массиве, а более компактно (один элемент массива занимает минимум 1 байт = 8 бит, а для переменной bool
// //достаточно одного бита)


// //создадим клон класса для переменной типа bool:
//template <>
//class Repository8<bool>{//специализируем шаблон класса Repository8 для работа с типом bool
// //реализация класса:
//private:
//    unsigned char m_data;//без знаковая переменная типа char, она занимает в памяти один байт, этого как раз хватит
//    //для хранения восьми занчений логического типа
//public:
//    Repository8() : m_data(0){}
//    void set(int index, bool value){
//        //выбираем оперируемый бит
//        unsigned char mask = 1 << index;//еденица: 00000001 =>, после сдвига на индекс (ели индекс = 3) 00001000
//        if(value)//если на входе у нас true, то бит нужно "включить"
//            m_data |= mask;//используем побитовое ИЛИ, чтобы "включить" бит
//        else//если на входе у нас false, то бит нужно "выключить"
//            m_data &= ~mask;//используем побитовое И, чтобы "выключить" бит
//    }
//    bool get(int index){
//        //выбираем бит
//        unsigned char mask = 1 << index;
//        //используем побитовое И для получения занчения бита, а затем выполняем его неявное преобразование
//        //в тип bool
//        return (m_data & mask) != 0;
//    }
//};

//*********************************************************************************************************************
//частичная специализация шаблонов. Выполняется только для шаблонов класса. Для шаблонов функции её нет.
//частичная специализация - это когда специализируемся не по всем параметрам шаблона, а только лишь по некоторым

// //Пример частичной специализации:

//template <typename T, typename S>//есть два параметра шаблона
//class Bar {};
// //специализируем только лишь один параметр, второй параметр оставим неопределённым
//template <typename U>
//class Bar<int, U> {};//первый параметр типа int, а второй оставили не определённым

// //можно ли написать частичную специализацию шаблона класса, у которого всего лишь один параметр шаблона
// //или получится только лишь полная специализация?
// // - Можно. Пример:

//template <class T>
//class Repository{
//private:
//    T m_value;
//public:
//    Repository(T value){
//        m_value = value;
//    }
//    ~Repository(){}
//    void print(){
//        std::cout << m_value << '\n';
//    }
//};
// //Частичная специализация этого шаблона:
//template <typename T>
//class Repository<T*>{//частичная специализация шаблона класса Repository для работы с типами указателей
//private:
//    T* m_value;
//public:
//    Repository(T* value){// T - тип указателя
//        //Выполняем глубокое копирование
//        m_value = new T(*value);//здесь копируется только одно конкретное значение (не массив значений)
//    }
//    ~Repository(){
//        delete m_value;//а здесь выполняется удаление этого значения
//    }
//    void print(){
//        std::cout << *m_value << '\n';//выводит не сам указатель, а значение этого указателя
//    }
//};

// //Всё это мощьный механизм языка, позволяет один шаблон функций, а, непосредственно компилятором будут создаваться
// //необходимые шаблоны функций. Такой подход в программировании, когда мы пишим программу, которая генерирует программу,
// //которая в дальнейшем выполняется - МЕТАПРОГРАММИРОВАНИЕ.

//****************************************************************************************************************
//Ещё пример использования шаблонов
//программа вычисления факториала

template<unsigned n>
struct f {
    static const unsigned v = n * f<n-1>::v;
};

template<>
struct f<0>{
    static const unsigned v = 1;
};


int main()
{
const unsigned x = f<5>::v;
cout << x << endl;

    return 0;
}
