#include <iostream>
#include <iomanip>
#include <vector>
#include <algorithm>
#include <cassert>

using namespace std;

//*****************************************************************************************
//перечисления

//enum Colors{
//    RED,    //0
//    GREEN,  //1
//    YELLOW, //2
//    BLUE,   //3
//    BLACK   //4
//};


//int main()
//{

//    Colors color;
//    color = BLUE;
//    cout << color << endl;//выдаст: 3
//    return 0;
//}

//***********************************************************************************************
//можно задавать свои значения элементам

//enum Colors{
//    RED = 10,   //10
//    GREEN,      //11
//    YELLOW,     //12
//    BLUE,       //13
//    BLACK       //14
//};


//int main()
//{

//    Colors color;
//    color = BLUE;
//    cout << color << endl;//выдаст: 13
//    return 0;
//}

//**********************************************************************************************
//можно задавать отрицательные значения, только целые

//enum Colors{
//    RED = -4,   //-4
//    GREEN,      //-3
//    YELLOW,     //-2
//    BLUE,       //-1
//    BLACK       //0
//};


//int main()
//{

//    Colors color;
//    color = BLUE;
//    cout << color << endl;//выдаст: -1
//    return 0;
//}

//**********************************************************************************************
//можно устанавливать разные значения, некоторым элементам. Можно, но, не рекомендуется присваивать одинаковые значения
//всем элементам

//enum Colors{
//    RED = -4,   //-4
//    GREEN,      //-3
//    YELLOW = 7,     //7
//    BLUE,       //8
//    BLACK       //9
//};


//int main()
//{

//    Colors color;
//    color = BLUE;
//    cout << color << endl;//выдаст: 8
//    return 0;
//}

//*******************************************************************************************
//присваивание значения переменной явно и указывая значение элемента

//enum Colors{
//    RED = -4,
//    GREEN,
//    YELLOW = 7,
//    BLUE,
//    BLACK
//};


//int main()
//{

//    Colors color;
//    color = static_cast<Colors>(8);//значение 8 будет преобразовано в тип Colors и присвоено переменной color
// //так можно присваивать значение переменной не явно указывая элемент BLUE, а указывая значение элемента перечисления 8
//    cout << color << endl;
//    return 0;
//}

//**********************************************************************************************
//как сделать так, чтобы выводилось не значение элемента, а его название BLUE?

//enum Colors{
//    RED,
//    GREEN,
//    YELLOW,
//    BLUE,
//    BLACK
//};


//int main()
//{
//    //можно создать массив:
//    string colorNames[5]{"RED", "GREEN", "YELLOW", "BLUE", "BLACK"};
//    Colors color;
//    color = static_cast<Colors>(3);
//    cout << colorNames[color] << endl;//Выводить название через массив
//    cout << color << endl;

//    return 0;
//}

//*******************************************************************************************

//enum Colors{
//    RED,
//    GREEN,
//    YELLOW,
//    BLUE,
//    BLACK
//};
// //некое перечисление с ошибками, как пример:
//enum ParseResult{
//    SUCCESS,
//    ERROR_OPENING_FILE = -1,
//    ERROR_PARSING_FILE = -2,
//    ERROR_READING_FILE = -3
//};


//int main()
//{
//    Colors color = RED;
//    ParseResult error = SUCCESS;
// if(color == error){//Разные типы переменных, но сравнение их работает, так как сравниваются их номера в перечислениях
//     //чтобы такого небыло, в место обычных перечислений используют классы перечислений
//    cout << "equal" << endl;
// }

//    return 0;
//}

//*************************************************************************************************************
//классы перечислений

//enum class Colors{//enum class и class - это разные вещи!
//    RED,
//    GREEN,
//    YELLOW,
//    BLUE,
//    BLACK
//};
// //некое перечисление с ошибками, как пример:
//enum class ParseResult{
//    SUCCESS,
//    ERROR_OPENING_FILE = -1,
//    ERROR_PARSING_FILE = -2,
//    ERROR_READING_FILE = -3
//};


//int main()
//{
//    Colors color = Colors::RED;//запись для присвоения значения переменной элемету класса перечислений
//    ParseResult error = ParseResult::SUCCESS;
// if(color == error){//возникает ошибка при сравнении переменных разных типов, поэтому это предпочтительней
//    cout << "equal" << endl;
// }
//    return 0;
//}

//*************************************************************************************************************
//отношения между объектами в С++. Композиция - построение сложного объекта из более простых.

//class Human{
//public:
//    void Think(){
//        brain.Think();
//    }
//private:
//    class Brain{
//    public:
//        void Think(){
//            cout << "I'm thinking" << endl;
//        }
//    };
//    Brain brain;
//};
// //Мы можем обратиться к методу класса Brain только через класс Human. Напрямую к мозгу мы обратиться не можем.


//int main()
//{
//Human human;
//human.Think();

//    return 0;
//}

//***********************************************************************************************************
//Агрегация - отношение части и целого, но, часть существует не под управлением целого.

//class Cap{
//private:
//    string color = "red";
//public:
//    void getColor(){
//        cout << "The color is " << color << endl;
//    }
//};

//class Human{
//public:
//    void Think(){
//        brain.Think();
//    }
//    void InspectTheCap(){
//        cap.getColor();
//    }
//private:
//    class Brain{
//    public:
//        void Think(){
//            cout << "I'm thinking" << endl;
//        }
//    };
//    Brain brain;
//    Cap cap;
//};


//int main()
//{
//Human human;
//human.Think();
//human.InspectTheCap();

//    return 0;
//}

//***********************************************************************************************************
//Ассоциация - отношения между двумя равноправными объектами.

//class Car{
//private:
//    string m_name;
//    int m_id;
//public:
//    Car(string name, int id) : m_name(name), m_id(id){}
//    string getName(){ return  m_name; }
//    int getId(){ return m_id; }
//};

//class CarLot{//Гараж, состоит из статических полей и методов. Статический класс.
//private:
//    static Car s_carLot[4];//массив автомобилей
//public:
//    CarLot() = delete;//тут мы удаляем конструктор по умолчанию, нельзя создать объект этого класса
//    static Car* getCar(int id){
//        for(int count = 0; count < 4; ++count)//тут проходим по всем элементам в массиве
//            if(s_carLot[count].getId() == id)
//                return &(s_carLot[count]);// если id, введённый в качестве параметра совпадает с id одного из 4-х
//         //автобобилей в гараже, то метод возвращает указатель на этот автомобиль.
//        return nullptr;
//    }
//};

//Car CarLot::s_carLot[4] = { Car("Camry", 5), Car("Focus", 14), Car("Vito", 73), Car("Levante", 58) };//инициализируем
// //массив.
//class Driver{
//private:
//    string m_name;
//    int m_carId;//для связывания классов используется эта переменная. тут происходит привязка водителя к автомобилю
//public:
//    Driver(string name, int carId) : m_name(name), m_carId(carId){}
//    string getName(){ return  m_name; }
//    int getCarId(){ return m_carId; }
//};

//int main()
//{
//Driver d("Ivan", 14);// Иван водит машину с Id 14
//Car *car = CarLot::getCar(d.getCarId());//получаем этот автомобиль из CarLot
//if (car)//если указатель не пустой
//    cout << d.getName() <<" is driving a " << car->getName() <<'\n';
//else
//    cout << d.getName() <<" couldn't find his car\n";

//    return 0;
//}

//********************************************************************************************************
//Зависимость - когда изменение спецификации класса-поставщика может повлиять на работу зависимого класса,
 //но не наоборот. Это отношение слабее чем ассоциация.

//********************************************************************************************************
//контейнерные классы - предназначен для организации и хранения объектов определённого типа данных.
//Что-то вороде массива.
//Стандартная библиотека шаблонов С++ STL (состоит из 3-х составляющих: контейнерные классы, итераторы, алгоритмы)
//контейнеры: последовательные, ассоциативные, адаптеры.
//последовательные - элементы находятся в определённой последовательности в памяти. Можно вставить элемент
//куда угодно в контейнер (начало, конец, середина...)
//ассоциативные - автоматически сортируют все свои элементы.
//адаптеры сепецифичные классы, предназначенные для той или иной ситуации. Пример: стек и очередь.

//std::vector - динамический массив. Сложность работы с динамическими массивами в С++: память выделяется во время
//выполнения программы, приходится перевыделять память. В vector вся работа по динамическому веделению памяти
//скрыта внутри класса.
//подключаем заголовочный файл #include <vector>

//int main()
//{
//    vector<int> array = {5, 2, 9, -1, 7};
//    array[2] = 10;
//    cout << array[2] << endl;

//    return 0;
//}

//********************************************************************************************************
//методы класса vector. size и resize


//int main()
//{
//    vector<int> array = {5, 2, 9, -1, 7};

//    array.resize(7);//изменяет размер текущего вектора на другой. В данном примере, размер увеличился с 5 до 7
//    //при этом два последних элемента будут нулевыми. Можно изменить в меньшую сторону, тогда часть элементов
//    //обрежется (удалится)

//    cout << array.size() << endl;//выводит количество элементов в векторе.


//    return 0;
//}

//********************************************************************************************************
//методы класса vector. push_back, pop_back, clear, empty

//int main()
//{
//    vector<int> array = {5, 2, 9, -1, 7};

//    array.push_back(1);//добавляет в конец вектора новый элемент

//    cout << array.size() << endl;//выводит количество элементов в векторе.

//    array.pop_back();//удаляет последний элемент из вектора

//    cout << array.size() << endl;

//    array.clear();//удаляет все элементы

//    cout << array.size() << endl;
//    cout << array.empty() << endl;//возвращает еденицу, если вектор пустой и ноль, если нет.


//    return 0;
//}

//*****************************************************************************************
//методы класса vector. back, front, at


//int main()
//{
//    vector<int> array = {5, 2, 9, -1, 7};

//    cout << array.back() << endl;//Возвращает последний элемент из вектора
//    cout << array.front() << endl;//возвращает первый элемент из вектора
//    cout << array.at(3) << endl;//возвращает любой, указанный, элемент из вектора, этот метод аналогичен обычному
//    //оператору индексации array[3]

//    //можно создавать вектора других типов данных, например, строк:
//    vector<string> array2;

//    return 0;
//}

//*********************************************************************************************
//итераторы. (для понимания, к ним можно относиться как к указателям на какой-то элемент контейнерного класса)

//int main()
//{
//    vector<int> array = {5, 2, 9, -1, 7};

//    //Создадим итератор, для этого, сначала пишем тип контейнерного класса, потом ::iterator, потом его нужно
//    //проинициализировать - сделать так, чтобы он указывал на начало нашего вектора

//    vector<int>::iterator it;
//    it = array.begin();//метод begin возвращает итератор на начальный элемент.
//    for(; it != array.end(); it++){//цикл, до тех пор пока итератор не дойдёт до последнего элемента, будем увеличивать
//        //it на еденицу и будем выводить элементы вектора:
//        cout << *it << " ";
//    }

//    return 0;
//}

//*********************************************************************************************
//алгоритмические функции. Большинство этих функций работают не с самими контейнерами, а с итераторами

//подключим заголовочный файл #include <algorithm> с алгоритмами

//int main()
//{
//    vector<int> array = {5, 2, 9, -1, 7};

//    sort(array.begin(), array.end());//вызовем функцию sort, у неё 2 параметра(итератор на начальный элемент вектора,
//    // итератор на конечный элемент вектора. Эта функция сортирует элементы вектора по возрастанию
//    //можно отсортировать не весь вектор, а одну его часть:sort(array.begin(), array.end()-2); - из последнего
//    //вычесть 2.


//    vector<int>::iterator it;
//    it = array.begin();//метод begin возвращает итератор на начальный элемент.
//    for(; it != array.end(); it++){//цикл, до тех пор пока итератор не дойдёт до последнего элемента, будем увеличивать
//        //it на еденицу и будем выводить элементы вектора:
//        cout << *it << " ";
//    }

//    return 0;
//}

//**********************************************************************************************************
//как создать свой собственный контейнерный класс

class ArrayInt{
private:
    int m_lenght;//длина
    int *m_data;//указатель на область памяти
public:
    ArrayInt() : m_lenght(0), m_data(nullptr){}//конструктор без параметров
    ArrayInt(int lenght) : m_lenght(lenght){//конструктор с параметром (с указанием длины)
        assert(lenght >= 0);//это проверка, если длина меньше нуля, то программа выдаст ошибку
    //функция assert проверяет условие, если оно верное, то она ничего не делает, если нет - то возникает ошибка.
    //чтобы она работала нужен заголовочный файл #include <cassert>

    if(lenght > 0)//также проверяем, если длина больше 0, то мы выделяем память размером этой длины
        m_data = new int[lenght];
    else
        m_data = nullptr;
    }
    ~ArrayInt(){//диструктор будет освобождать память
        delete [] m_data;
    }
    void erase(){//этот метод будет очищать весь нашь массив от значений
        delete [] m_data;//освобождаем память
        m_data = nullptr;//указателю присваиваем значение нулевого указателя
        m_lenght = 0;//и обнуляем длину
    }
    int getLenght() const {//гет метод для возвращения длины
        return m_lenght;
    }
    int& operator[] (int index){//этим методом мы перегружаем оператор индексации, для того чтобы иметь
        //возможность получать элементы нашего массива через оператор []
        assert(index >= 0 && index < m_lenght);
        return m_data[index];
        }
    void resize(int newLenght){//будет принимать параметр новой длины
        if(newLenght == m_lenght) return;//если новая длина равна текущей, то просто выходим из этого метода
        if(newLenght <= 0){//если новая длина меньше или равна нулю, то
            erase();//очищаем массив
            return;//и выходим из метода
        }
        int *data = new int[newLenght];//выделяем новую область памяти размером новой длины
        if(m_lenght > 0){//если у нас текущая длина больше нуля
            //то, мы должны посчитать сколько элементов нам нужно скопировать
            int elementsToCopy = newLenght > m_lenght ? m_lenght : newLenght;//сравниваем новую длину и текущую,
            //и берём меньшую из них (это тернарный оператор). Далее в цикле:
            for(int i=0; i<elementsToCopy; i++){//будет происходить копирование данных в новую область памяти
                data[i] = m_data[i];
            }
        }
        delete [] m_data;//после того как данные скопированы, освобождаем старую область памяти
        m_data = data;//далее указателю присваиваем значение новой области памяти
        m_lenght = newLenght;//и обновляем длину
    }
    void insertBefore(int value, int index){//метод вставки нового элемента внуть нашего массива
        //проверка корректности передаваемого индекса
        assert(index >= 0 && index <= m_lenght);
        //создаём новый массив на один элемент больше старого массива
        int *data = new int[m_lenght+1];
        //копируем все элементы до индекса
        for(int before=0; before < index; ++before)
            data[before] = m_data[before];
        //вставляем новый элемент в новый массив
        data [index] = value;
        //копируем все значения после вставляемого элемента
        for(int after=index; after < m_lenght; ++after)
            data[after+1] = m_data[after];
        //удаляем старый массив и используем вместо него новый
        delete [] m_data;
        m_data = data;
        ++m_lenght;
    }
    //метод вставки нового элемента в конец нашего массива
    void push_back(int value){//воспользуемся существующим методом insertBefore
        insertBefore(value, m_lenght);
    }
};

int main()
{


    return 0;
}
