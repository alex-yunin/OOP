#include <iostream>
#include <iomanip>
#include <sstream>
#include <vector>
#include <algorithm>

using namespace std;

//*****************************************************************************************************
//Стандартные потоки

//int main()
//{
//    cout <<"Enter your age: ";
//    int age;
//    cin >> age;
//    if(age < 0){
//        cerr << "Error!" <<endl;
//        exit(1);
//    }
//    cout << "Your age is " << age <<endl;

//****************************************************************************************************
//функционал класса ostream

//int main()
//{
//cout.setf(ios::showpos);//обратились к стандартному потоку cout, вызвали у него метод setf для включения флага
// //и включили флаг showpos. Этот флаг ставит знак + перед положительными числами
//cout << 30 << endl;//из-за включённого флага showpos, на выводе получим "+30"

// //для отображения чисел в других системах счисления:
//cout.setf(ios::hex);//этот флаг выводит все числа в шестнадцатиричной системе счисления
//cout << 30 << endl;
// //ничего не произойдёт, так как сначала нужно отключить флаг отображения в десятичной системе счисления:

//    cout.unsetf(ios::dec);//выключаем флаг десетичной системы счисления
//    cout.setf(ios::hex);
//    cout << 30 << endl;
//    //выведется "1e"

//****************************************************************************************************************
//манипуляторы - некие объекты, которые помещаются внутрь потока и влияют на вывод данных

//int main()
//{
//    cout << hex << 30 << endl;//помещаем внутрь потока объект hex
//    cout << 49 << endl;//также будет выводиться в шестнадцатиричном виде, так как в поток уже поместили hex
//*********************************************************
//    cout << oct << 30 << endl;//восьмиричное представление.
//    cout << 49 << endl;
 //преимущества манипуляторов - не нужно отключать предыдущий флаг прежде чем включить другой

 //как мы можем влиять на логическую переменную?
//    bool f = false;
//    cout << f << endl;//выводится в виде числа 0 или 1. Чтобы выводить "тексктом" поместим в поток boolalpha
//    cout << boolalpha << f << endl;
//    cout << showpos << 40 << endl;//выводит +40
    //манипуляторы для вещественных чисел************************************************
//    cout << fixed << setprecision(2) << 123.4567 << endl;//setprecision(2) - вывод двух знаков после запятой (округление
//    //по правилам математики)
//    cout << scientific << setprecision(2) << 123.4567 << endl;//scientific - для вывода в экспоненциальной форме, но
//    //с округлением setprecision(2) до двух знаков после запятой для экспоненциального вида: 1.23е+02 = 123
//    cout << scientific << setprecision(5) << 123.4567 << endl;//выведет 1.23457е+02 = 123,457

    //манипуляторы для работы с выводом символов и строк******************************
//    cout << setw(10) << -12345 << endl;//setw(10) - установка ширины. Выведет: "    -12345". Команда устанавливает 10
//    //символо-мест и по умолчанию выравнивает по правому краю
//    cout << setw(10) << left << -12345 << endl;//Выведет: "-12345    ". left - выравнивание по левому краю

//    cout.fill('*');//задаёт символ заполнитель (в место пробела по умолчанию), в данном случае "*"
//    cout << setw(10) << -12345 << endl;
//    cout << setw(10) << left << -12345 << endl;

//*****************************************************************************************************************
//функционал класса istream. Позволяет извлекать данные из потока.

//int main()
//{
//    char buf[12];//массив символов на 12 мест
    //cin >> buf;//вводим данные в этот массив, если символов будет больше 12 - это будет переполнение и данные потеряются.
    // чтобы этого избежать, нужно ограничить количество символов, которые можно ввести используюя
    //манипулятор setw(12)
//    cin >> setw(12) >> buf;//теперь, программв прочитает только первые 11 символов из фходного потока
    //остальные символы останутся в потоке до следующего извлечения.
    //строка символов оканчивается "0" - признак окончания строки (0-терминатор)

    //есть другой способ считывания данных - это функция get
    //cin.get(buf, 12);//результат работы будет таким же как и в предыдущем примере. Проблема в том, что метод get не
    //считывает символ новой строки. Чтобы считывался символ начала новой строки используют метод getline
//    cin.getline(buf, 12);//работает также как и предыдущий, но может считывать символы новой строки

    //как считывать обычные строки?
//    string s;//строка
//    getline(cin, s);//входной поток cin передаётся в функцию как параметр, вторым параметром передаётся наша строка
//    //в резулютате выполнения этой функции в строку s будут записаны те данные, которые мы введём в консоль
//    cout << s << endl;

//*************************************************************************************************************
//потоковые классы строк. Подключим библиотеку <sstream>

//int main()
//{
//    //создадим объект класса stringstream - это и есть потоковый класс строк
//    stringstream str_stream;
//    //далее мы можем поместить в этот поток какую либо строку
//    str_stream << "Hello!";
//    //если мы хотим извлечь из потока строк нашу строку
//    string s;
//    str_stream >> s;//извлекаем из потока в переменную s нашу строку
//    cout << s << endl;//выведем на экран эту строку

    //с помощью потоков можно преобразовывать данные

//    stringstream str_stream;
//    int x = 765;//это число попробуем преобразовать в тип string
//    str_stream << x;//мы можем поместить этот элемент в строковый поток
//    string s;
//    str_stream >> s;//далее извлечь из этого потока уже в переменную типа string
//    cout << s << endl;

    //можно сделать и на оборот:

//    stringstream str_stream;
//    int x;
//    string s = "332";
//    str_stream << s;
//    str_stream >> x;
//    cout << x << endl;
    //можно записать 2 переменные подряд в поток, и потом 2 извлеч

    //есть специальная функция, которая конвертирует число в строку
//    double x = 5.43;
//    string s = to_string(x);
//    cout << s << endl;

//******************************************************************************************************
//перегрузка оператора вывода и ввода


//class Date{
//private:
//    int m_day, m_month, m_year;
//public:
//    Date(int d, int m, int y): m_day(d), m_month(m), m_year(y){ }
//    friend ostream& operator<< (ostream& out, const Date& date){
//        out << "Date: " << date.m_day << "." << date.m_month << "." << date.m_year << "\n";
//        return out;
//    }
//    friend istream& operator>> (istream& in, Date& date){
//        in >> date.m_day;
//        in >> date.m_month;
//        in >> date.m_year;
//        return in;
//    }
//};

//int main(){
//    Date today(1, 10, 2020);
//    cin >> today;
//    cout << today;

//*******************************************************************************************************
//Валидация пользовательского ввода


//int main(){
//    bool wrong_name = false;
//    string s;
//    getline(cin, s);//данные для имени берём из потока
//    for(int i=0; i < s.length(); i++){//s.length() считает количество символов в строке
//        if(i == 0 && !isalpha(s[i])){//isalpha(s[i]) - функция проверяет что i-й символ строки s является буквой
//            wrong_name = true;
//            break;
//        }
//        else if(!isalnum(s[i])){//если i !=0, т. е символ не первый, на месте символа должна быть либо буква,
//            //либо цифра. Функция isalnum(s[i]) проверяет что это буква или цифра
//            wrong_name = true;
//            break;
//        }
//    }
//    //после цикла делаем проверку:
//    if(wrong_name)
//        cout << "Error!" << endl;
//    else
//        cout << "Correct!" << endl;
//    //*************************************************
//    //функции проверки
//    isdigit('3');//проверяет что символ цифра
//    isspace(' ');//проверяет что символ пробел

//***********************************************************************************************************
//методы класса string

int main(){
//    string s = "Hello world!";
//    cout << s.size() << endl;//возвращает число символов в строке
//    cout << s.length() << endl;//так же возвращает длину строки
//    cout << s.max_size() << endl;//Возвращает максимальное число символов, которое может быть помещено в данную строку
//    s.resize(7);//обрывает строку в данном примере на 7 символах
//    cout << s << endl;
//    s.clear();//очищает всю строку
//    cout << s << endl;
//    cout << s.empty() << endl;//проверяет является ли строка пустой, так как этот метод возвращает булевое значение,
//    //то можно вывод отформотировать для текстового отображения булевых значений:
//    cout << boolalpha << s.empty() << endl;
//    cout << s[1] << endl;//для получения какого-то символа в строе можно воспользоваться оператором индексации
//    cout << s.at(2) << endl;//либо методом at
//    cout << s.back() << endl;//для получения последнего символа строки
//    cout << s.front() << endl;//для получения первого символа строки
//    s += " I em back!";//в конец строки s добавляем новую строку
//    cout << s << endl;
//    s.insert(5, ", ");//в заданную позицию строки s добаляет другую строку
//    cout << s << endl;
//    s.replace(5, 4, " W");//метод заменяет часть строки(replace(позичия, сколько символов заменить, на что заменить)
//    //можно заменить на пустую строку "" - тогда будет просто удалены указанные символы в строке
//    cout << s << endl;
//    cout << s << endl;
//    int pos = s.find("l");//возвращает позицию символа, если его найдёт. Он находит первое вхождение строки в строку
//    cout << pos << endl;
//    pos = s.find("wo");
//    cout << pos << endl;
//    pos = s.find("l", 3);//искать строку начиная с третьей позиции
//    cout << pos << endl;
//    pos = s.rfind("l", 7);//ищет строку от седьмого символа к началу строки
//    cout << pos << endl;
//    string subs = s.substr(3, 2);//возвращает часть строки (в примере идёт на третий символ в строке
//    //и берёт от туда два символа)
//    cout << subs << endl;
    string s = "hello world!";
    string s2 = "hello world!";
    cout << s.compare(s2) << endl;//если строка s > s2, то возвращает положительное число,
    //если s == s2, то возвращает 0, если s < s2, то возвращает отрицательное число. Сравнение идёт по символьно
    //по таблице "ASCI"




return 0;
}
