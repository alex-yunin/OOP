//Курс: "Объектно-ориентированное программирование".
//Студент: Александр Юнин
//Выполнение Практического задания к уроку 4.

#include <iostream>
#include <iomanip>
#include <vector>
#include <algorithm>
#include <cassert>

using namespace std;

//Код_1.1 для задачи 1 ************************************************** Код_1.1 для задачи 1

//Код написанный на уроке************************************************ Код написанный на уроке

class ArrayInt{
private:
    int m_lenght;//длина
    int *m_data;//указатель на область памяти
public:
    ArrayInt() : m_lenght(0), m_data(nullptr){}//конструктор без параметров
    ArrayInt(int lenght) : m_lenght(lenght){//конструктор с параметром (с указанием длины)
        assert(lenght >= 0);//это проверка, если длина меньше нуля, то программа выдаст ошибку
    //функция assert проверяет условие, если оно верное, то она ничего не делает, если нет - то возникает ошибка.
    //чтобы она работала нужен заголовочный файл #include <cassert>

    if(lenght > 0)//также проверяем, если длина больше 0, то мы выделяем память размером этой длины
        m_data = new int[lenght];
    else
        m_data = nullptr;
    }
    ~ArrayInt(){//диструктор будет освобождать память
        delete [] m_data;
    }
    void erase(){//этот метод будет очищать весь нашь массив от значений
        delete [] m_data;//освобождаем память
        m_data = nullptr;//указателю присваиваем значение нулевого указателя
        m_lenght = 0;//и обнуляем длину
    }
    int getLenght() const {//гет метод для возвращения длины
        return m_lenght;
    }
    int& operator[] (int index){//этим методом мы перегружаем оператор индексации, для того чтобы иметь
        //возможность получать элементы нашего массива через оператор []
        assert(index >= 0 && index < m_lenght);
        return m_data[index];
        }
    void resize(int newLenght){//будет принимать параметр новой длины
        if(newLenght == m_lenght) return;//если новая длина равна текущей, то просто выходим из этого метода
        if(newLenght <= 0){//если новая длина меньше или равна нулю, то
            erase();//очищаем массив
            return;//и выходим из метода
        }
        int *data = new int[newLenght];//выделяем новую область памяти размером новой длины
        if(m_lenght > 0){//если у нас текущая длина больше нуля
            //то, мы должны посчитать сколько элементов нам нужно скопировать
            int elementsToCopy = newLenght > m_lenght ? m_lenght : newLenght;//сравниваем новую длину и текущую,
            //и берём меньшую из них (это тернарный оператор). Далее в цикле:
            for(int i=0; i<elementsToCopy; i++){//будет происходить копирование данных в новую область памяти
                data[i] = m_data[i];
            }
        }
        delete [] m_data;//после того как данные скопированы, освобождаем старую область памяти
        m_data = data;//далее указателю присваиваем значение новой области памяти
        m_lenght = newLenght;//и обновляем длину
    }
    void insertBefore(int value, int index){//метод вставки нового элемента внуть нашего массива
        //проверка корректности передаваемого индекса
        assert(index >= 0 && index <= m_lenght);
        //создаём новый массив на один элемент больше старого массива
        int *data = new int[m_lenght+1];
        //копируем все элементы до индекса
        for(int before=0; before < index; ++before)
            data[before] = m_data[before];
        //вставляем новый элемент в новый массив
        data [index] = value;
        //копируем все значения после вставляемого элемента
        for(int after=index; after < m_lenght; ++after)
            data[after+1] = m_data[after];
        //удаляем старый массив и используем вместо него новый
        delete [] m_data;
        m_data = data;
        ++m_lenght;
    }
    //метод вставки нового элемента в конец нашего массива
    void push_back(int value){//воспользуемся существующим методом insertBefore
        insertBefore(value, m_lenght);
    }
//Конец кода написанного на уроке**************************************** Конец кода написанного на уроке

    //Метод удаления последнего элемента массива
    void pop_back(){//Воспользуемся методом изменения длины
        resize(m_lenght-1);
    }

    //метод удаления первого элемента массива
    void pop_front(){
        if(m_lenght <= 1){//если длина текущего массива меньше или равна еденице, то
            erase();//очищаем массив
            return;//выходим из метода
        }
        int *data = new int[m_lenght-1];//выделяем новую область памяти с длиной меньшей на еденицу
        //копируем элементы в новую область памяти начиная со второго
        for(int i=1; i<m_lenght; i++){
            data[i-1] = m_data[i];
        }
        delete [] m_data;//после того как данные скопированны, освобождаем старую область памяти
        m_data = data;//указателю присваиваем значение новой области памяти
        --m_lenght;//и обновляем длину
    }

    //метод для сортировки массива
    void sort(){
        if(m_lenght <= 1){//если длина текущего массива меньше или равна еденице, то
            return;//выходим из метода
        }
        int tmp, i, j;//инициализируем временные переменные
        //Производим сортировку массива:
        for(i=0; i<m_lenght-1; i++){
            for(j=0; j<m_lenght-1; j++){
                if(m_data[j] > m_data[j+1]){
                    tmp = m_data[j];
                    m_data[j] = m_data[j+1];
                    m_data[j+1] = tmp;
                }
            }
        }
    }

    //метод вывода на экран элементов
    void print(){
        if(m_lenght <= 0){//проверяем, если длина массива меньше или равна нулю, то
            cout << "Массив пуст!" << endl;//выводим сообщение что массив пуст
        }
        for(int i=0; i<m_lenght; i++){//выводим на экран элементы массива
            cout << m_data[i] << " ";
        }
        cout << endl;
    }
};


//Конец кода_1.1 для задачи 1 ******************************************* Конец кода_1.1 для задачи 1

//Код_2.1 для задачи 2 ************************************************** Код_2.1 для задачи 2

void sizeDifferent(vector<int> arr){
    sort(arr.begin(), arr.end());//Сортируем массив
    int siz, tmp, i;
    tmp = 0;
    siz = arr.size();
    for(i=0; i<siz-1; i++){//считаем количество дубликатов
            if(arr.at(i) == arr.at(i+1)){
                ++tmp;
            }
    }
    siz = siz - tmp;//находим количество различных чисел
    cout << siz << endl;
}

//Конец кода_2.1 для задачи 2 ******************************************* Конец кода_2.1 для задачи 2

//Код_3.1 для задачи 3 ************************************************** Код_3.1 для задачи 3

class Card{
protected:
    enum suit{ HEARTS, DIAMONDS, CLUBS, SPADES };//масть. червы, бубны, трефы, пики
    enum rank{ TWO, THREE, FOUR, FIVE, SIX, SEVEN, EIGHT, NINE, TEN, JACK, QUEEN, KING, ACE };
    bool m_IsFaceUp;
    suit m_Suit;
    rank m_Rank;
public:
    Card(){}
    void Flip(){
        if(m_IsFaceUp == 0)
            m_IsFaceUp = 1;
        else
            m_IsFaceUp = 0;
    }
    int getValue(){ return m_Rank; }
};

class Hand{
protected:
    vector<Card*> m_Cards;//набор указателей на объекты типа Card
public:
    Hand(){}
    void Add(Card* pCard){
        m_Cards.push_back(pCard);
    }
    void Clear(){
        m_Cards.clear();
    }
    int getTotal(){
        int total = 0;
        vector<int> tmp;
        int Size = m_Cards.size();
        for(int i=0; i<Size; i++){
            tmp.push_back(m_Cards.at(i)->getValue());
        }
        sort(tmp.begin(), tmp.end());
        for(int i=0; i<Size; i++){
            if(tmp.at(i) <= 8){
                total = total + tmp.at(i) + 2;
            }
            if(tmp.at(i) > 8 && tmp.at(i) < 12){
                total = total + 10;
            }
            if(tmp.at(i) == 12 && total <= 10){
                total = total +11;
            }
            if(tmp.at(i) == 12 && total > 10){
                total = total + 1;
            }
        }
        return total;
    }
};


//Конец кода_3.1 для задачи 3 ******************************************* Конец кода_3.1 для задачи 3

int main()
{
//Код_1.2 для задачи 1 ************************************************** Код_1.2 для задачи 1

    ArrayInt ar(6);
    ar.print();
    cout << "Введите дополнительные 6 элементов массива:" <<endl;
    for(int i=0; i<6; i++){
        int tmp;
        scanf("%d", &tmp);
        ar.insertBefore(tmp, i);
    }
    ar.print();
    ar.resize(6);
    ar.print();
    ar.sort();
    ar.print();
    ar.pop_back();
    ar.print();
    ar.pop_front();
    ar.print();

//Конец кода_1.2 для задачи 1 ******************************************* Конец кода_1.2 для задачи 1

//Код_2.2 для задачи 2 ************************************************** Код_2.2 для задачи 2

    vector<int> arr = {5, 2, 1, 2, 3, 4, 2, 5};
    sizeDifferent(arr);

//Конец кода_2.2 для задачи 2 ******************************************* Конец кода_2.2 для задачи 2

//Код_3.2 для задачи 3 ************************************************** Код_3.2 для задачи 3



//Конец кода_3.2 для задачи 3 ******************************************* Конец кода_3.2 для задачи 3




    return 0;
}
